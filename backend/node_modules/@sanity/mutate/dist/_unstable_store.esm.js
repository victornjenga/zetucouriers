import { finalize, share, ReplaySubject, timer, Subject, merge, map, EMPTY, lastValueFrom, toArray, defer, filter, mergeMap, of, tap } from "rxjs";
import { decodeAll } from "./_legacy/decode.esm.js";
import { applyPatch } from "mendoza";
import { nanoid } from "nanoid";
import { assignId, hasId, applyPatchMutation, applyNodePatch, applyPatches } from "./_legacy/utils.esm.js";
import { stringifyPatches, makePatches } from "@sanity/diff-match-patch";
import { getAtPath } from "./_legacy/getAtPath.esm.js";
import { startsWith, stringify } from "./_legacy/stringify.esm.js";
function omitRev(document) {
  if (document === void 0)
    return;
  const { _rev, ...doc } = document;
  return doc;
}
function applyMendozaPatch(document, patch2) {
  const next = applyPatch(omitRev(document), patch2);
  return next === null ? void 0 : next;
}
function getMutationDocumentId(mutation) {
  if (mutation.type === "patch")
    return mutation.id;
  if (mutation.type === "create")
    return mutation.document._id;
  if (mutation.type === "delete")
    return mutation.id;
  if (mutation.type === "createIfNotExists" || mutation.type === "createOrReplace")
    return mutation.document._id;
  throw new Error("Invalid mutation type");
}
function applyAll(current, mutation) {
  return mutation.reduce((doc, m) => {
    const res = applyDocumentMutation(doc, m);
    if (res.status === "error")
      throw new Error(res.message);
    return res.status === "noop" ? doc : res.after;
  }, current);
}
function applyDocumentMutation(document, mutation) {
  if (mutation.type === "create")
    return create(document, mutation);
  if (mutation.type === "createIfNotExists")
    return createIfNotExists(document, mutation);
  if (mutation.type === "delete")
    return del(document, mutation);
  if (mutation.type === "createOrReplace")
    return createOrReplace(document, mutation);
  if (mutation.type === "patch")
    return patch(document, mutation);
  throw new Error(`Invalid mutation type: ${mutation.type}`);
}
function create(document, mutation) {
  if (document)
    return { status: "error", message: "Document already exist" };
  const result = assignId(mutation.document, nanoid);
  return { status: "created", id: result._id, after: result };
}
function createIfNotExists(document, mutation) {
  return hasId(mutation.document) ? document ? { status: "noop" } : { status: "created", id: mutation.document._id, after: mutation.document } : {
    status: "error",
    message: "Cannot createIfNotExists on document without _id"
  };
}
function createOrReplace(document, mutation) {
  return hasId(mutation.document) ? document ? {
    status: "updated",
    id: mutation.document._id,
    before: document,
    after: mutation.document
  } : { status: "created", id: mutation.document._id, after: mutation.document } : {
    status: "error",
    message: "Cannot createIfNotExists on document without _id"
  };
}
function del(document, mutation) {
  return document ? mutation.id !== document._id ? { status: "error", message: "Delete mutation targeted wrong document" } : {
    status: "deleted",
    id: mutation.id,
    before: document,
    after: void 0
  } : { status: "noop" };
}
function patch(document, mutation) {
  if (!document)
    return {
      status: "error",
      message: "Cannot apply patch on nonexistent document"
    };
  const next = applyPatchMutation(mutation, document);
  return document === next ? { status: "noop" } : { status: "updated", id: mutation.id, before: document, after: next };
}
function applyMutations(mutations, dataset) {
  var _a;
  const updatedDocs = /* @__PURE__ */ Object.create(null);
  for (const mutation of mutations) {
    const documentId = getMutationDocumentId(mutation);
    if (!documentId)
      throw new Error("Unable to get document id from mutation");
    const before = ((_a = updatedDocs[documentId]) == null ? void 0 : _a.after) || dataset.get(documentId), res = applyDocumentMutation(before, mutation);
    if (res.status === "error")
      throw new Error(res.message);
    res.status !== "noop" && (res.status === "updated" || res.status === "created" || res.status === "deleted") && (documentId in updatedDocs || (updatedDocs[documentId] = { before, after: void 0, muts: [] }), updatedDocs[documentId].after = res.after);
  }
  return Object.entries(updatedDocs).map(
    // eslint-disable-next-line no-shadow
    ([id, { before, after, muts }]) => ({
      id,
      status: after ? before ? "updated" : "created" : "deleted",
      mutations: muts,
      before,
      after
    })
  );
}
function commit(results, dataset) {
  results.forEach((result) => {
    (result.status === "created" || result.status === "updated") && dataset.set(result.id, result.after), result.status === "deleted" && dataset.delete(result.id);
  });
}
function createDataset() {
  const documents = /* @__PURE__ */ new Map();
  return {
    set: (id, doc) => void documents.set(id, doc),
    get: (id) => documents.get(id),
    delete: (id) => documents.delete(id)
  };
}
function takeUntilRight(arr, predicate, opts) {
  const result = [];
  for (const item of arr.slice().reverse()) {
    if (predicate(item))
      return result;
    result.push(item);
  }
  return result.reverse();
}
function isEqualPath(p1, p2) {
  return stringify(p1) === stringify(p2);
}
function supersedes(later, earlier) {
  return (earlier.type === "set" || earlier.type === "unset") && (later.type === "set" || later.type === "unset");
}
function squashNodePatches(patches) {
  return compactSetIfMissingPatches(
    compactSetPatches(compactUnsetPatches(patches))
  );
}
function compactUnsetPatches(patches) {
  return patches.reduce(
    (earlierPatches, laterPatch) => {
      if (laterPatch.op.type !== "unset")
        return earlierPatches.push(laterPatch), earlierPatches;
      const unaffected = earlierPatches.filter(
        (earlierPatch) => !startsWith(laterPatch.path, earlierPatch.path)
      );
      return unaffected.push(laterPatch), unaffected;
    },
    []
  );
}
function compactSetPatches(patches) {
  return patches.reduceRight(
    (laterPatches, earlierPatch) => (laterPatches.find(
      (later) => supersedes(later.op, earlierPatch.op) && isEqualPath(later.path, earlierPatch.path)
    ) || laterPatches.unshift(earlierPatch), laterPatches),
    []
  );
}
function compactSetIfMissingPatches(patches) {
  return patches.reduce(
    (previousPatches, laterPatch) => laterPatch.op.type !== "setIfMissing" ? (previousPatches.push(laterPatch), previousPatches) : (takeUntilRight(
      previousPatches,
      (patch2) => patch2.op.type === "unset"
    ).find(
      (precedingPatch) => precedingPatch.op.type === "setIfMissing" && isEqualPath(precedingPatch.path, laterPatch.path)
    ) || previousPatches.push(laterPatch), previousPatches),
    []
  );
}
function compactDMPSetPatches(base, patches) {
  let edge = base;
  return patches.reduce(
    (earlierPatches, laterPatch) => {
      const before = edge;
      if (edge = applyNodePatch(laterPatch, edge), laterPatch.op.type === "set" && typeof laterPatch.op.value == "string") {
        const current = getAtPath(laterPatch.path, before);
        if (typeof current == "string") {
          const replaced = {
            ...laterPatch,
            op: {
              type: "diffMatchPatch",
              value: stringifyPatches(
                makePatches(current, laterPatch.op.value)
              )
            }
          };
          return earlierPatches.flatMap((ep) => isEqualPath(ep.path, laterPatch.path) && ep.op.type === "diffMatchPatch" ? [] : ep).concat(replaced);
        }
      }
      return earlierPatches.push(laterPatch), earlierPatches;
    },
    []
  );
}
function squashDMPStrings(remote, mutationGroups) {
  return mutationGroups.map((mutationGroup) => ({
    ...mutationGroup,
    mutations: dmpIfyMutations(remote, mutationGroup.mutations)
  }));
}
function dmpIfyMutations(store, mutations) {
  return mutations.map((mutation, i) => mutation.type === "patch" ? dmpifyPatchMutation(store.get(mutation.id), mutation) : mutation);
}
function dmpifyPatchMutation(base, mutation) {
  return base ? {
    ...mutation,
    patches: compactDMPSetPatches(base, mutation.patches)
  } : mutation;
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module, exports) {
  (function() {
    var undefined$1, VERSION = "4.17.21", LARGE_ARRAY_SIZE = 200, CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`", HASH_UNDEFINED = "__lodash_hash_undefined__", MAX_MEMOIZE_SIZE = 500, PLACEHOLDER = "__lodash_placeholder__", CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4, COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2, WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512, DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...", HOT_COUNT = 800, HOT_SPAN = 16, LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3, INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = NaN, MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1, wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ], argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g, reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source), reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g, reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source), reTrimStart = /^\s+/, reWhitespace = /\s/, reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /, reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/, reEscapeChar = /\\(\\)?/g, reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, reFlags = /\w*$/, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsHostCtor = /^\[object .+?Constructor\]$/, reIsOctal = /^0o[0-7]+$/i, reIsUint = /^(?:0|[1-9]\d*)$/, reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, reNoMatch = /($^)/, reUnescapedString = /['\n\r\u2028\u2029\\]/g, rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange, rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d", rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")", reApos = RegExp(rsApos, "g"), reComboMark = RegExp(rsCombo, "g"), reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"), reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g"), reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"), reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], templateCounter = -1, typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
    var deburredLetters = {
      // Latin-1 Supplement block.
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      // Latin Extended-A block.
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    }, htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, freeParseFloat = parseFloat, freeParseInt = parseInt, freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), freeExports = exports && !exports.nodeType && exports, freeModule = freeExports && !0 && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        return types || freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch {
      }
    }(), nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      for (var index = -1, length = array == null ? 0 : array.length; ++index < length; ) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      for (var index = -1, length = array == null ? 0 : array.length; ++index < length && iteratee(array[index], index, array) !== !1; )
        ;
      return array;
    }
    function arrayEachRight(array, iteratee) {
      for (var length = array == null ? 0 : array.length; length-- && iteratee(array[length], length, array) !== !1; )
        ;
      return array;
    }
    function arrayEvery(array, predicate) {
      for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
        if (!predicate(array[index], index, array))
          return !1;
      return !0;
    }
    function arrayFilter(array, predicate) {
      for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array[index];
        predicate(value, index, array) && (result[resIndex++] = value);
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
        if (comparator(value, array[index]))
          return !0;
      return !1;
    }
    function arrayMap(array, iteratee) {
      for (var index = -1, length = array == null ? 0 : array.length, result = Array(length); ++index < length; )
        result[index] = iteratee(array[index], index, array);
      return result;
    }
    function arrayPush(array, values) {
      for (var index = -1, length = values.length, offset = array.length; ++index < length; )
        array[offset + index] = values[index];
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      for (initAccum && length && (accumulator = array[++index]); ++index < length; )
        accumulator = iteratee(accumulator, array[index], index, array);
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      for (initAccum && length && (accumulator = array[--length]); length--; )
        accumulator = iteratee(accumulator, array[length], length, array);
      return accumulator;
    }
    function arraySome(array, predicate) {
      for (var index = -1, length = array == null ? 0 : array.length; ++index < length; )
        if (predicate(array[index], index, array))
          return !0;
      return !1;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      return eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2))
          return result = key, !1;
      }), result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length; )
        if (predicate(array[index], index, array))
          return index;
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      for (var index = fromIndex - 1, length = array.length; ++index < length; )
        if (comparator(array[index], value))
          return index;
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      return eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection2);
      }), accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      for (array.sort(comparer); length--; )
        array[length] = array[length].value;
      return array;
    }
    function baseSum(array, iteratee) {
      for (var result, index = -1, length = array.length; ++index < length; ) {
        var current = iteratee(array[index]);
        current !== undefined$1 && (result = result === undefined$1 ? current : result + current);
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      for (var index = -1, result = Array(n); ++index < n; )
        result[index] = iteratee(index);
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string && string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "");
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
        ;
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1; )
        ;
      return index;
    }
    function countHolders(array, placeholder) {
      for (var length = array.length, result = 0; length--; )
        array[length] === placeholder && ++result;
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters), escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      for (var data, result = []; !(data = iterator.next()).done; )
        result.push(data.value);
      return result;
    }
    function mapToArray(map2) {
      var index = -1, result = Array(map2.size);
      return map2.forEach(function(value, key) {
        result[++index] = [key, value];
      }), result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length; ) {
        var value = array[index];
        (value === placeholder || value === PLACEHOLDER) && (array[index] = PLACEHOLDER, result[resIndex++] = index);
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      return set.forEach(function(value) {
        result[++index] = value;
      }), result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      return set.forEach(function(value) {
        result[++index] = [value, value];
      }), result;
    }
    function strictIndexOf(array, value, fromIndex) {
      for (var index = fromIndex - 1, length = array.length; ++index < length; )
        if (array[index] === value)
          return index;
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      for (var index = fromIndex + 1; index--; )
        if (array[index] === value)
          return index;
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      for (var index = string.length; index-- && reWhitespace.test(string.charAt(index)); )
        ;
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      for (var result = reUnicode.lastIndex = 0; reUnicode.test(string); )
        ++result;
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
      var Array2 = context.Array, Date = context.Date, Error2 = context.Error, Function2 = context.Function, Math = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String = context.String, TypeError = context.TypeError, arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype, coreJsData = context["__core-js_shared__"], funcToString = funcProto.toString, hasOwnProperty = objectProto.hasOwnProperty, idCounter = 0, maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }(), nativeObjectToString = objectProto.toString, objectCtorString = funcToString.call(Object2), oldDash = root._, reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Buffer = moduleExports ? context.Buffer : undefined$1, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1, symIterator = Symbol ? Symbol.iterator : undefined$1, symToStringTag = Symbol ? Symbol.toStringTag : undefined$1, defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          return func({}, "", {}), func;
        } catch {
        }
      }(), ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout, nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse, DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create"), metaMap = WeakMap && new WeakMap(), realNames = {}, dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap), symbolProto = Symbol ? Symbol.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper)
            return value;
          if (hasOwnProperty.call(value, "__wrapped__"))
            return wrapperClone(value);
        }
        return new LodashWrapper(value);
      }
      var baseCreate = /* @__PURE__ */ function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto))
            return {};
          if (objectCreate)
            return objectCreate(proto);
          object.prototype = proto;
          var result2 = new object();
          return object.prototype = undefined$1, result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: reEscape,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: reEvaluate,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: reInterpolate,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: lodash2
        }
      }, lodash2.prototype = baseLodash.prototype, lodash2.prototype.constructor = lodash2, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        return result2.__actions__ = copyArray(this.__actions__), result2.__dir__ = this.__dir__, result2.__filtered__ = this.__filtered__, result2.__iteratees__ = copyArray(this.__iteratees__), result2.__takeCount__ = this.__takeCount__, result2.__views__ = copyArray(this.__views__), result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1, result2.__filtered__ = !0;
        } else
          result2 = this.clone(), result2.__dir__ *= -1;
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length)
          return baseWrapperValue(array, this.__actions__);
        var result2 = [];
        outer:
          for (; length-- && resIndex < takeCount; ) {
            index += dir;
            for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength; ) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG)
                value = computed;
              else if (!computed) {
                if (type == LAZY_FILTER_FLAG)
                  continue outer;
                break outer;
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        return this.size -= result2 ? 1 : 0, result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value, this;
      }
      Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [], this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0)
          return !1;
        var lastIndex = data.length - 1;
        return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined$1 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this;
      }
      ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        for (this.clear(); ++index < length; ) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0, this.__data__ = {
          hash: new Hash(),
          map: new (Map2 || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key).delete(key);
        return this.size -= result2 ? 1 : 0, result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        return data.set(key, value), this.size += data.size == size2 ? 0 : 1, this;
      }
      MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        for (this.__data__ = new MapCache(); ++index < length; )
          this.add(values2[index]);
      }
      function setCacheAdd(value) {
        return this.__data__.set(value, HASH_UNDEFINED), this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache(), this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data.delete(key);
        return this.size = data.size, result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1)
            return pairs.push([key, value]), this.size = ++data.size, this;
          data = this.__data__ = new MapCache(pairs);
        }
        return data.set(key, value), this.size = data.size, this;
      }
      Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String) : [], length = result2.length;
        for (var key in value)
          (inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length))) && result2.push(key);
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) && baseAssignValue(object, key, value);
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) && baseAssignValue(object, key, value);
      }
      function assocIndexOf(array, key) {
        for (var length = array.length; length--; )
          if (eq(array[length][0], key))
            return length;
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        return baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        }), accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        key == "__proto__" && defineProperty ? defineProperty(object, key, {
          configurable: !0,
          enumerable: !0,
          value,
          writable: !0
        }) : object[key] = value;
      }
      function baseAt(object, paths) {
        for (var index = -1, length = paths.length, result2 = Array2(length), skip = object == null; ++index < length; )
          result2[index] = skip ? undefined$1 : get(object, paths[index]);
        return result2;
      }
      function baseClamp(number, lower, upper) {
        return number === number && (upper !== undefined$1 && (number = number <= upper ? number : upper), lower !== undefined$1 && (number = number >= lower ? number : lower)), number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer && (result2 = object ? customizer(value, key, object, stack) : customizer(value)), result2 !== undefined$1)
          return result2;
        if (!isObject(value))
          return value;
        var isArr = isArray(value);
        if (isArr) {
          if (result2 = initCloneArray(value), !isDeep)
            return copyArray(value, result2);
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value))
            return cloneBuffer(value, isDeep);
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            if (result2 = isFlat || isFunc ? {} : initCloneObject(value), !isDeep)
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
          } else {
            if (!cloneableTags[tag])
              return object ? value : {};
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked)
          return stacked;
        stack.set(value, result2), isSet(value) ? value.forEach(function(subValue) {
          result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        }) : isMap(value) && value.forEach(function(subValue, key2) {
          result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys, props = isArr ? undefined$1 : keysFunc(value);
        return arrayEach(props || value, function(subValue, key2) {
          props && (key2 = subValue, subValue = value[key2]), assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        }), result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null)
          return !length;
        for (object = Object2(object); length--; ) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value))
            return !1;
        }
        return !0;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        return setTimeout(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = !0, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length)
          return result2;
        iteratee2 && (values2 = arrayMap(values2, baseUnary(iteratee2))), comparator ? (includes2 = arrayIncludesWith, isCommon = !1) : values2.length >= LARGE_ARRAY_SIZE && (includes2 = cacheHas, isCommon = !1, values2 = new SetCache(values2));
        outer:
          for (; ++index < length; ) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
              for (var valuesIndex = valuesLength; valuesIndex--; )
                if (values2[valuesIndex] === computed)
                  continue outer;
              result2.push(value);
            } else includes2(values2, computed, comparator) || result2.push(value);
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn), baseEachRight = createBaseEach(baseForOwnRight, !0);
      function baseEvery(collection, predicate) {
        var result2 = !0;
        return baseEach(collection, function(value, index, collection2) {
          return result2 = !!predicate(value, index, collection2), result2;
        }), result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        for (var index = -1, length = array.length; ++index < length; ) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed)))
            var computed = current, result2 = value;
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        for (start = toInteger(start), start < 0 && (start = -start > length ? 0 : length + start), end = end === undefined$1 || end > length ? length : toInteger(end), end < 0 && (end += length), end = start > end ? 0 : toLength(end); start < end; )
          array[start++] = value;
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        return baseEach(collection, function(value, index, collection2) {
          predicate(value, index, collection2) && result2.push(value);
        }), result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        for (predicate || (predicate = isFlattenable), result2 || (result2 = []); ++index < length; ) {
          var value = array[index];
          depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result2) : arrayPush(result2, value) : isStrict || (result2[result2.length] = value);
        }
        return result2;
      }
      var baseFor = createBaseFor(), baseForRight = createBaseFor(!0);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        for (var index = 0, length = path.length; object != null && index < length; )
          object = object[toKey(path[index++])];
        return index && index == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        return value == null ? value === undefined$1 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        for (var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = 1 / 0, result2 = []; othIndex--; ) {
          var array = arrays[othIndex];
          othIndex && iteratee2 && (array = arrayMap(array, baseUnary(iteratee2))), maxLength = nativeMin(array.length, maxLength), caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          for (; ++index < length && result2.length < maxLength; ) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (value = comparator || value !== 0 ? value : 0, !(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              for (othIndex = othLength; --othIndex; ) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator)))
                  continue outer;
              }
              seen && seen.push(computed), result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        return baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        }), accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object), object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        return value === other ? !0 : value == null || other == null || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other))
            return !1;
          objIsArr = !0, objIsObj = !1;
        }
        if (isSameTag && !objIsObj)
          return stack || (stack = new Stack()), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            return stack || (stack = new Stack()), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        return isSameTag ? (stack || (stack = new Stack()), equalObjects(object, other, bitmask, customizer, equalFunc, stack)) : !1;
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null)
          return !length;
        for (object = Object2(object); index--; ) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object))
            return !1;
        }
        for (; ++index < length; ) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object))
              return !1;
          } else {
            var stack = new Stack();
            if (customizer)
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2))
              return !1;
          }
        }
        return !0;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value))
          return !1;
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        return typeof value == "function" ? value : value == null ? identity : typeof value == "object" ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object))
          return nativeKeys(object);
        var result2 = [];
        for (var key in Object2(object))
          hasOwnProperty.call(object, key) && key != "constructor" && result2.push(key);
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object))
          return nativeKeysIn(object);
        var isProto = isPrototype(object), result2 = [];
        for (var key in object)
          key == "constructor" && (isProto || !hasOwnProperty.call(object, key)) || result2.push(key);
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        return baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        }), result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        return matchData.length == 1 && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function(object) {
          var objValue = get(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        object !== source && baseFor(source, function(srcValue, key) {
          if (stack || (stack = new Stack()), isObject(srcValue))
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            newValue === undefined$1 && (newValue = srcValue), assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1, isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : (!isObject(objValue) || isFunction(objValue)) && (newValue = initCloneObject(srcValue))) : isCommon = !1;
        }
        isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack.delete(srcValue)), assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (length)
          return n += n < 0 ? length : 0, isIndex(n, length) ? array[n] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        iteratees.length ? iteratees = arrayMap(iteratees, function(iteratee2) {
          return isArray(iteratee2) ? function(value) {
            return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
          } : iteratee2;
        }) : iteratees = [identity];
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { criteria, index: ++index, value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        for (var index = -1, length = paths.length, result2 = {}; ++index < length; ) {
          var path = paths[index], value = baseGet(object, path);
          predicate(value, path) && baseSet(result2, castPath(path, object), value);
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        for (array === values2 && (values2 = copyArray(values2)), iteratee2 && (seen = arrayMap(array, baseUnary(iteratee2))); ++index < length; )
          for (var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value; (fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1; )
            seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1);
        return array;
      }
      function basePullAt(array, indexes) {
        for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--; ) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length); length--; )
          result2[fromRight ? length : ++index] = start, start += step;
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER)
          return result2;
        do
          n % 2 && (result2 += string), n = nativeFloor(n / 2), n && (string += string);
        while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject(object))
          return object;
        path = castPath(path, object);
        for (var index = -1, length = path.length, lastIndex = length - 1, nested = object; nested != null && ++index < length; ) {
          var key = toKey(path[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype")
            return object;
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1, newValue === undefined$1 && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {});
          }
          assignValue(nested, key, newValue), nested = nested[key];
        }
        return object;
      }
      var baseSetData = metaMap ? function(func, data) {
        return metaMap.set(func, data), func;
      } : identity, baseSetToString = defineProperty ? function(func, string) {
        return defineProperty(func, "toString", {
          configurable: !0,
          enumerable: !1,
          value: constant(string),
          writable: !0
        });
      } : identity;
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
        for (var result2 = Array2(length); ++index < length; )
          result2[index] = array[index + start];
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        return baseEach(collection, function(value, index, collection2) {
          return result2 = predicate(value, index, collection2), !result2;
        }), !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          for (; low < high; ) {
            var mid = low + high >>> 1, computed = array[mid];
            computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0)
          return 0;
        value = iteratee2(value);
        for (var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1; low < high; ) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined$1, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN)
            var setLow = retHighest || othIsReflexive;
          else valIsUndefined ? setLow = othIsReflexive && (retHighest || othIsDefined) : valIsNull ? setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : othIsNull || othIsSymbol ? setLow = !1 : setLow = retHighest ? computed <= value : computed < value;
          setLow ? low = mid + 1 : high = mid;
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        for (var index = -1, length = array.length, resIndex = 0, result2 = []; ++index < length; ) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        return typeof value == "number" ? value : isSymbol(value) ? NAN : +value;
      }
      function baseToString(value) {
        if (typeof value == "string")
          return value;
        if (isArray(value))
          return arrayMap(value, baseToString) + "";
        if (isSymbol(value))
          return symbolToString ? symbolToString.call(value) : "";
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = !0, result2 = [], seen = result2;
        if (comparator)
          isCommon = !1, includes2 = arrayIncludesWith;
        else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2)
            return setToArray(set2);
          isCommon = !1, includes2 = cacheHas, seen = new SetCache();
        } else
          seen = iteratee2 ? [] : result2;
        outer:
          for (; ++index < length; ) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (value = comparator || value !== 0 ? value : 0, isCommon && computed === computed) {
              for (var seenIndex = seen.length; seenIndex--; )
                if (seen[seenIndex] === computed)
                  continue outer;
              iteratee2 && seen.push(computed), result2.push(value);
            } else includes2(seen, computed, comparator) || (seen !== result2 && seen.push(computed), result2.push(value));
          }
        return result2;
      }
      function baseUnset(object, path) {
        return path = castPath(path, object), object = parent(object, path), object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        for (var length = array.length, index = fromRight ? length : -1; (fromRight ? index-- : ++index < length) && predicate(array[index], index, array); )
          ;
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        return result2 instanceof LazyWrapper && (result2 = result2.value()), arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2)
          return length ? baseUniq(arrays[0]) : [];
        for (var index = -1, result2 = Array2(length); ++index < length; )
          for (var array = arrays[index], othIndex = -1; ++othIndex < length; )
            othIndex != index && (result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator));
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        for (var index = -1, length = props.length, valsLength = values2.length, result2 = {}; ++index < length; ) {
          var value = index < valsLength ? values2[index] : undefined$1;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        return end = end === undefined$1 ? length : end, !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep)
          return buffer.slice();
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        return buffer.copy(result2), result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        return new Uint8Array(result2).set(new Uint8Array(arrayBuffer)), result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        return result2.lastIndex = regexp.lastIndex, result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value), othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive)
            return 1;
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive)
            return -1;
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length; ) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength)
              return result2;
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength; )
          result2[leftIndex] = partials[leftIndex];
        for (; ++argsIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result2[holders[argsIndex]] = args[argsIndex]);
        for (; rangeLength--; )
          result2[leftIndex++] = args[argsIndex++];
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength; )
          result2[argsIndex] = args[argsIndex];
        for (var offset = argsIndex; ++rightIndex < rightLength; )
          result2[offset + rightIndex] = partials[rightIndex];
        for (; ++holdersIndex < holdersLength; )
          (isUncurried || argsIndex < argsLength) && (result2[offset + holders[holdersIndex]] = args[argsIndex++]);
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        for (array || (array = Array2(length)); ++index < length; )
          array[index] = source[index];
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        for (var index = -1, length = props.length; ++index < length; ) {
          var key = props[index], newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          newValue === undefined$1 && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          for (customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined$1 : customizer, length = 1), object = Object2(object); ++index < length; ) {
            var source = sources[index];
            source && assigner(object, source, index, customizer);
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null)
            return collection;
          if (!isArrayLike(collection))
            return eachFunc(collection, iteratee2);
          for (var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection); (fromRight ? index-- : ++index < length) && iteratee2(iterable[index], index, iterable) !== !1; )
            ;
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          for (var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length; length--; ) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === !1)
              break;
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1, chr = strSymbols ? strSymbols[0] : string.charAt(0), trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          for (var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper); index--; )
            args[index] = arguments[index];
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          if (length -= holders.length, length < arity)
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection), predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          for (fromRight && funcs.reverse(); index--; ) {
            var func = funcs[index];
            if (typeof func != "function")
              throw new TypeError(FUNC_ERROR_TEXT);
            if (prereq && !wrapper && getFuncName(func) == "wrapper")
              var wrapper = new LodashWrapper([], !0);
          }
          for (index = wrapper ? index : length; ++index < length; ) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1 ? wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value))
              return wrapper.plant(value).value();
            for (var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value; ++index2 < length; )
              result2 = funcs[index2].call(this, result2);
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          for (var length = arguments.length, args = Array2(length), index = length; index--; )
            args[index] = arguments[index];
          if (isCurried)
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), isAry && ary2 < length && (args.length = ary2), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)), fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1)
            return defaultValue;
          if (value !== undefined$1 && (result2 = value), other !== undefined$1) {
            if (result2 === undefined$1)
              return other;
            typeof value == "string" || typeof other == "string" ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2)
          return charsLength ? baseRepeat(chars, length) : chars;
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength; )
            args[leftIndex] = partials[leftIndex];
          for (; argsLength--; )
            args[leftIndex++] = arguments[++argsIndex];
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          return step && typeof step != "number" && isIterateeCall(start, end, step) && (end = step = undefined$1), start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          return typeof value == "string" && typeof other == "string" || (value = toNumber(value), other = toNumber(other)), operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG), bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ], result2 = wrapFunc.apply(undefined$1, newData);
        return isLaziable(func) && setData(result2, newData), result2.placeholder = placeholder, setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math[methodName];
        return function(number, precision) {
          if (number = toNumber(number), precision = precision == null ? 0 : nativeMin(toInteger(precision), 292), precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            return pair = (toString(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY ? function(values2) {
        return new Set(values2);
      } : noop;
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        var length = partials ? partials.length : 0;
        if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined$1), ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0), arity = arity === undefined$1 ? arity : toInteger(arity), length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func), newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)), !bitmask || bitmask == WRAP_BIND_FLAG)
          var result2 = createBind(func, bitmask, thisArg);
        else bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? result2 = createCurry(func, bitmask, arity) : (bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length ? result2 = createPartial(func, bitmask, thisArg, partials) : result2 = createHybrid.apply(undefined$1, newData);
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        return objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue), baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack), stack.delete(srcValue)), objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength))
          return !1;
        var arrStacked = stack.get(array), othStacked = stack.get(other);
        if (arrStacked && othStacked)
          return arrStacked == other && othStacked == array;
        var index = -1, result2 = !0, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        for (stack.set(array, other), stack.set(other, array); ++index < arrLength; ) {
          var arrValue = array[index], othValue = other[index];
          if (customizer)
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          if (compared !== undefined$1) {
            if (compared)
              continue;
            result2 = !1;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack)))
                return seen.push(othIndex);
            })) {
              result2 = !1;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = !1;
            break;
          }
        }
        return stack.delete(array), stack.delete(other), result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset)
              return !1;
            object = object.buffer, other = other.buffer;
          case arrayBufferTag:
            return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            if (convert || (convert = setToArray), object.size != other.size && !isPartial)
              return !1;
            var stacked = stack.get(object);
            if (stacked)
              return stacked == other;
            bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            return stack.delete(object), result2;
          case symbolTag:
            if (symbolValueOf)
              return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
        return !1;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial)
          return !1;
        for (var index = objLength; index--; ) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key)))
            return !1;
        }
        var objStacked = stack.get(object), othStacked = stack.get(other);
        if (objStacked && othStacked)
          return objStacked == other && othStacked == object;
        var result2 = !0;
        stack.set(object, other), stack.set(other, object);
        for (var skipCtor = isPartial; ++index < objLength; ) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer)
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = !1;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          objCtor != othCtor && "constructor" in object && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor) && (result2 = !1);
        }
        return stack.delete(object), stack.delete(other), result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = metaMap ? function(func) {
        return metaMap.get(func);
      } : noop;
      function getFuncName(func) {
        for (var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0; length--; ) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func)
            return data.name;
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        return result2 = result2 === iteratee ? baseIteratee : result2, arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map3, key) {
        var data = map3.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        for (var result2 = keys(object), length = result2.length; length--; ) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = !0;
        } catch {
        }
        var result2 = nativeObjectToString.call(value);
        return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result2;
      }
      var getSymbols = nativeGetSymbols ? function(object) {
        return object == null ? [] : (object = Object2(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        }));
      } : stubArray, getSymbolsIn = nativeGetSymbols ? function(object) {
        for (var result2 = []; object; )
          arrayPush(result2, getSymbols(object)), object = getPrototype(object);
        return result2;
      } : stubArray, getTag = baseGetTag;
      (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) && (getTag = function(value) {
        var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString)
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        return result2;
      });
      function getView(start, end, transforms) {
        for (var index = -1, length = transforms.length; ++index < length; ) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return { start, end };
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        for (var index = -1, length = path.length, result2 = !1; ++index < length; ) {
          var key = toKey(path[index]);
          if (!(result2 = object != null && hasFunc(object, key)))
            break;
          object = object[key];
        }
        return result2 || ++index != length ? result2 : (length = object == null ? 0 : object.length, !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object)));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        return length && typeof array[0] == "string" && hasOwnProperty.call(array, "index") && (result2.index = array.index, result2.input = array.input), result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length)
          return source;
        var lastIndex = length - 1;
        return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), source.replace(reWrapComment, `{
/* [wrapped with ` + details + `] */
`);
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        return length = length == null ? MAX_SAFE_INTEGER : length, !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object))
          return !1;
        var type = typeof index;
        return (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) ? eq(object[index], value) : !1;
      }
      function isKey(value, object) {
        if (isArray(value))
          return !1;
        var type = typeof value;
        return type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value) ? !0 : reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype))
          return !1;
        if (func === other)
          return !0;
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          return object == null ? !1 : object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key;
        }), cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG), isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo))
          return data;
        srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), value = source[7], value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8])), data[9] == null && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask, data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null)
          for (var key in Object2(object))
            result2.push(key);
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        return start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0), function() {
          for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length); ++index < length; )
            array[index] = args[start + index];
          index = -1;
          for (var otherArgs = Array2(start + 1); ++index < start; )
            otherArgs[index] = args[index];
          return otherArgs[start] = transform2(array), apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--; ) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (!(key === "constructor" && typeof object[key] == "function") && key != "__proto__")
          return object[key];
      }
      var setData = shortOut(baseSetData), setTimeout = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      }, setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          if (lastCalled = stamp, remaining > 0) {
            if (++count >= HOT_COUNT)
              return arguments[0];
          } else
            count = 0;
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        for (size2 = size2 === undefined$1 ? length : size2; ++index < size2; ) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index], array[index] = value;
        }
        return array.length = size2, array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        return string.charCodeAt(0) === 46 && result2.push(""), string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        }), result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value))
          return value;
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch {
          }
          try {
            return func + "";
          } catch {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        return arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
        }), details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper)
          return wrapper.clone();
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        return result2.__actions__ = copyArray(wrapper.__actions__), result2.__index__ = wrapper.__index__, result2.__values__ = wrapper.__values__, result2;
      }
      function chunk(array, size2, guard) {
        (guard ? isIterateeCall(array, size2, guard) : size2 === undefined$1) ? size2 = 1 : size2 = nativeMax(toInteger(size2), 0);
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1)
          return [];
        for (var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2)); index < length; )
          result2[resIndex++] = baseSlice(array, index, index += size2);
        return result2;
      }
      function compact(array) {
        for (var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = []; ++index < length; ) {
          var value = array[index];
          value && (result2[resIndex++] = value);
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length)
          return [];
        for (var args = Array2(length - 1), array = arguments[0], index = length; index--; )
          args[index - 1] = arguments[index];
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0)) : [];
      }), differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2)) : [];
      }), differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        return isArrayLikeObject(comparator) && (comparator = undefined$1), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, !0), undefined$1, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array, n < 0 ? 0 : n, length)) : [];
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array, 0, n < 0 ? 0 : n)) : [];
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        return length ? (start && typeof start != "number" && isIterateeCall(array, value, start) && (start = 0, end = length), baseFill(array, value, start, end)) : [];
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length)
          return -1;
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length)
          return -1;
        var index = length - 1;
        return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), baseFindIndex(array, getIteratee(predicate, 3), index, !0);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        return length ? (depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(array, depth)) : [];
      }
      function fromPairs(pairs) {
        for (var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {}; ++index < length; ) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length)
          return -1;
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      }), intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return iteratee2 === last(mapped) ? iteratee2 = undefined$1 : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      }), intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, comparator && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length)
          return -1;
        var index = length;
        return fromIndex !== undefined$1 && (index = toInteger(fromIndex), index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        return basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending)), result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length))
          return result2;
        var index = -1, indexes = [], length = array.length;
        for (predicate = getIteratee(predicate, 3); ++index < length; ) {
          var value = array[index];
          predicate(value, index, array) && (result2.push(value), indexes.push(index));
        }
        return basePullAt(array, indexes), result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        return length ? (end && typeof end != "number" && isIterateeCall(array, start, end) ? (start = 0, end = length) : (start = start == null ? 0 : toInteger(start), end = end === undefined$1 ? length : toInteger(end)), baseSlice(array, start, end)) : [];
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value))
            return index;
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, !0);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), !0);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, !0) - 1;
          if (eq(array[index], value))
            return index;
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        return array && array.length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), baseSlice(array, 0, n < 0 ? 0 : n)) : [];
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        return length ? (n = guard || n === undefined$1 ? 1 : toInteger(n), n = length - n, baseSlice(array, n < 0 ? 0 : n, length)) : [];
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0));
      }), unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee2, 2));
      }), unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined$1, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        return comparator = typeof comparator == "function" ? comparator : undefined$1, array && array.length ? baseUniq(array, undefined$1, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length))
          return [];
        var length = 0;
        return array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group))
            return length = nativeMax(group.length, length), !0;
        }), baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length))
          return [];
        var result2 = unzip(array);
        return iteratee2 == null ? result2 : arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      }), xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      }), xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        return isArrayLikeObject(iteratee2) && (iteratee2 = undefined$1), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      }), xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        return comparator = typeof comparator == "function" ? comparator : undefined$1, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
      }), zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        return iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1, unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        return result2.__chain__ = !0, result2;
      }
      function tap2(value, interceptor) {
        return interceptor(value), value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        return length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start) ? this.thru(interceptor) : (value = value.slice(start, +start + (length ? 1 : 0)), value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined$1
        }), new LodashWrapper(value, this.__chain__).thru(function(array) {
          return length && !array.length && array.push(undefined$1), array;
        }));
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        this.__values__ === undefined$1 && (this.__values__ = toArray2(this.value()));
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { done, value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        for (var result2, parent2 = this; parent2 instanceof baseLodash; ) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0, clone2.__values__ = undefined$1, result2 ? previous.__wrapped__ = clone2 : result2 = clone2;
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        return previous.__wrapped__ = value, result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined$1
          }), new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        hasOwnProperty.call(result2, key) ? ++result2[key] : baseAssignValue(result2, key, 1);
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex), findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map2(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        return depth = depth === undefined$1 ? 1 : toInteger(depth), baseFlatten(map2(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        hasOwnProperty.call(result2, key) ? result2[key].push(value) : baseAssignValue(result2, key, [value]);
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        return baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        }), result2;
      }), keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map2(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        return collection == null ? [] : (isArray(iteratees) || (iteratees = iteratees == null ? [] : [iteratees]), orders = guard ? undefined$1 : orders, isArray(orders) || (orders = orders == null ? [] : [orders]), baseOrderBy(collection, iteratees, orders));
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        (guard ? isIterateeCall(collection, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n);
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null)
          return 0;
        if (isArrayLike(collection))
          return isString(collection) ? stringSize(collection) : collection.length;
        var tag = getTag(collection);
        return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined$1), func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null)
          return [];
        var length = iteratees.length;
        return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      }), now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        return n = toInteger(n), function() {
          if (--n < 1)
            return func.apply(this, arguments);
        };
      }
      function ary(func, n, guard) {
        return n = guard ? undefined$1 : n, n = func && n == null ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        return n = toInteger(n), function() {
          return --n > 0 && (result2 = func.apply(this, arguments)), n <= 1 && (func = undefined$1), result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      }), bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        return result2.placeholder = curry.placeholder, result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        return result2.placeholder = curryRight.placeholder, result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = !1, maxing = !1, trailing = !0;
        if (typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing);
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          return lastArgs = lastThis = undefined$1, lastInvokeTime = time, result2 = func.apply(thisArg, args), result2;
        }
        function leadingEdge(time) {
          return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time))
            return trailingEdge(time);
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          return timerId = undefined$1, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined$1, result2);
        }
        function cancel() {
          timerId !== undefined$1 && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
            if (timerId === undefined$1)
              return leadingEdge(lastCallTime);
            if (maxing)
              return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime);
          }
          return timerId === undefined$1 && (timerId = setTimeout(timerExpired, wait)), result2;
        }
        return debounced.cancel = cancel, debounced.flush = flush, debounced;
      }
      var defer2 = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      }), delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key))
            return cache.get(key);
          var result2 = func.apply(this, args);
          return memoized.cache = cache.set(key, result2) || cache, result2;
        };
        return memoized.cache = new (memoize.Cache || MapCache)(), memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length; )
            args[index] = transforms[index].call(this, args[index]);
          return apply(func, this, args);
        });
      }), partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      }), partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      }), rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        return start = start === undefined$1 ? start : toInteger(start), baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        return start = start == null ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          return array && arrayPush(otherArgs, array), apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = !0, trailing = !0;
        if (typeof func != "function")
          throw new TypeError(FUNC_ERROR_TEXT);
        return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length)
          return [];
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt), gte = createRelationalOperation(function(value, other) {
        return value >= other;
      }), isArguments = baseIsArguments(/* @__PURE__ */ function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      }, isArray = Array2.isArray, isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === !0 || value === !1 || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse, isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null)
          return !0;
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value)))
          return !value.length;
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag)
          return !value.size;
        if (isPrototype(value))
          return !baseKeys(value).length;
        for (var key in value)
          if (hasOwnProperty.call(value, key))
            return !1;
        return !0;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value))
          return !1;
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value))
          return !1;
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value))
          throw new Error2(CORE_ERROR_TEXT);
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag)
          return !1;
        var proto = getPrototype(value);
        if (proto === null)
          return !0;
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt), lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value)
          return [];
        if (isArrayLike(value))
          return isString(value) ? stringToArray(value) : copyArray(value);
        if (symIterator && value[symIterator])
          return iteratorToArray(value[symIterator]());
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value)
          return value === 0 ? value : 0;
        if (value = toNumber(value), value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number")
          return value;
        if (isSymbol(value))
          return NAN;
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string")
          return value === 0 ? value : +value;
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source)
          hasOwnProperty.call(source, key) && assignValue(object, key, source[key]);
      }), assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      }), assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      }), assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      }), at = flatRest(baseAt);
      function create2(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1, length = sources.length, guard = length > 2 ? sources[2] : undefined$1;
        for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length; )
          for (var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength; ) {
            var key = props[propsIndex], value = object[key];
            (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key]);
          }
        return object;
      }), defaultsDeep = baseRest(function(args) {
        return args.push(undefined$1, customDefaultsMerge), apply(mergeWith, undefined$1, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), result2[value] = key;
      }, constant(identity)), invertBy = createInverter(function(result2, value, key) {
        value != null && typeof value.toString != "function" && (value = nativeObjectToString.call(value)), hasOwnProperty.call(result2, value) ? result2[value].push(key) : result2[value] = [key];
      }, getIteratee), invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        }), result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        return iteratee2 = getIteratee(iteratee2, 3), baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        }), result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      }), mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      }), omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null)
          return result2;
        var isDeep = !1;
        paths = arrayMap(paths, function(path) {
          return path = castPath(path, object), isDeep || (isDeep = path.length > 1), path;
        }), copyObject(object, getAllKeysIn(object), result2), isDeep && (result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
        for (var length = paths.length; length--; )
          baseUnset(result2, paths[length]);
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null)
          return {};
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index = -1, length = path.length;
        for (length || (length = 1, object = undefined$1); ++index < length; ) {
          var value = object == null ? undefined$1 : object[toKey(path[index])];
          value === undefined$1 && (index = length, value = defaultValue), object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys), toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        if (iteratee2 = getIteratee(iteratee2, 4), accumulator == null) {
          var Ctor = object && object.constructor;
          isArrLike ? accumulator = isArr ? new Ctor() : [] : isObject(object) ? accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {} : accumulator = {};
        }
        return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        }), accumulator;
      }
      function unset(object, path) {
        return object == null ? !0 : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        return customizer = typeof customizer == "function" ? customizer : undefined$1, object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        return upper === undefined$1 && (upper = lower, lower = undefined$1), upper !== undefined$1 && (upper = toNumber(upper), upper = upper === upper ? upper : 0), lower !== undefined$1 && (lower = toNumber(lower), lower = lower === lower ? lower : 0), baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        return start = toFinite(start), end === undefined$1 ? (end = start, start = 0) : end = toFinite(end), number = toNumber(number), baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating) && (upper = floating = undefined$1), floating === undefined$1 && (typeof upper == "boolean" ? (floating = upper, upper = undefined$1) : typeof lower == "boolean" && (floating = lower, lower = undefined$1)), lower === undefined$1 && upper === undefined$1 ? (lower = 0, upper = 1) : (lower = toFinite(lower), upper === undefined$1 ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
          var temp = lower;
          lower = upper, upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        return word = word.toLowerCase(), result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        return string = toString(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string), target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        return position -= target.length, position >= 0 && string.slice(position, end) == target;
      }
      function escape(string) {
        return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      }), lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      }), lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string), length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length)
          return string;
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string), length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string), length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        return guard || radix == null ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        return (guard ? isIterateeCall(string, n, guard) : n === undefined$1) ? n = 1 : n = toInteger(n), baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        return limit && typeof limit != "number" && isIterateeCall(string, separator, limit) && (separator = limit = undefined$1), limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0, limit ? (string = toString(string), string && (typeof separator == "string" || separator != null && !isRegExp(separator)) && (separator = baseToString(separator), !separator && hasUnicode(string)) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit)) : [];
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith2(string, target, position) {
        return string = toString(string), position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length), target = baseToString(target), string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        guard && isIterateeCall(string, options, guard) && (options = undefined$1), string = toString(string), options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys), isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '", reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        ), sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + `
`;
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source += `' +
__e(` + escapeValue + `) +
'`), evaluateValue && (isEvaluating = !0, source += `';
` + evaluateValue + `;
__p += '`), interpolateValue && (source += `' +
((__t = (` + interpolateValue + `)) == null ? '' : __t) +
'`), index = offset + match.length, match;
        }), source += `';
`;
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable)
          source = `with (obj) {
` + source + `
}
`;
        else if (reForbiddenIdentifierChars.test(variable))
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source = "function(" + (variable || "obj") + `) {
` + (variable ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + source + `return __p
}`;
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        if (result2.source = source, isError(result2))
          throw result2;
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        if (string = toString(string), string && (guard || chars === undefined$1))
          return baseTrim(string);
        if (!string || !(chars = baseToString(chars)))
          return string;
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        if (string = toString(string), string && (guard || chars === undefined$1))
          return string.slice(0, trimmedEndIndex(string) + 1);
        if (!string || !(chars = baseToString(chars)))
          return string;
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        if (string = toString(string), string && (guard || chars === undefined$1))
          return string.replace(reTrimStart, "");
        if (!string || !(chars = baseToString(chars)))
          return string;
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength)
          return string;
        var end = length - stringSize(omission);
        if (end < 1)
          return omission;
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1)
          return result2 + omission;
        if (strSymbols && (end += result2.length - end), isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            for (separator.global || (separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g")), separator.lastIndex = 0; match = separator.exec(substring); )
              var newEnd = match.index;
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          index > -1 && (result2 = result2.slice(0, index));
        }
        return result2 + omission;
      }
      function unescape(string) {
        return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      }), upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        return string = toString(string), pattern = guard ? undefined$1 : pattern, pattern === undefined$1 ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      }), bindAll = flatRest(function(object, methodNames) {
        return arrayEach(methodNames, function(key) {
          key = toKey(key), baseAssignValue(object, key, bind(object[key], object));
        }), object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        return pairs = length ? arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function")
            throw new TypeError(FUNC_ERROR_TEXT);
          return [toIteratee(pair[0]), pair[1]];
        }) : [], baseRest(function(args) {
          for (var index = -1; ++index < length; ) {
            var pair = pairs[index];
            if (apply(pair[0], this, args))
              return apply(pair[1], this, args);
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow(), flowRight = createFlow(!0);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      }), methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        options == null && !(isObject(source) && (methodNames.length || !props.length)) && (options = source, source = object, object = this, methodNames = baseFunctions(source, keys(source)));
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        return arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain2 || chainAll) {
              var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
              return actions.push({ func, args: arguments, thisArg: object }), result2.__chain__ = chainAll, result2;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          });
        }), object;
      }
      function noConflict() {
        return root._ === this && (root._ = oldDash), this;
      }
      function noop() {
      }
      function nthArg(n) {
        return n = toInteger(n), baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap), overEvery = createOver(arrayEvery), overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange(), rangeRight = createRange(!0);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return !1;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return !0;
      }
      function times(n, iteratee2) {
        if (n = toInteger(n), n < 1 || n > MAX_SAFE_INTEGER)
          return [];
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2), n -= MAX_ARRAY_LENGTH;
        for (var result2 = baseTimes(length, iteratee2); ++index < n; )
          iteratee2(index);
        return result2;
      }
      function toPath(value) {
        return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0), ceil = createRound("ceil"), divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1), floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1), round = createRound("round"), subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      return lodash2.after = after, lodash2.ary = ary, lodash2.assign = assign, lodash2.assignIn = assignIn, lodash2.assignInWith = assignInWith, lodash2.assignWith = assignWith, lodash2.at = at, lodash2.before = before, lodash2.bind = bind, lodash2.bindAll = bindAll, lodash2.bindKey = bindKey, lodash2.castArray = castArray, lodash2.chain = chain, lodash2.chunk = chunk, lodash2.compact = compact, lodash2.concat = concat, lodash2.cond = cond, lodash2.conforms = conforms, lodash2.constant = constant, lodash2.countBy = countBy, lodash2.create = create2, lodash2.curry = curry, lodash2.curryRight = curryRight, lodash2.debounce = debounce, lodash2.defaults = defaults, lodash2.defaultsDeep = defaultsDeep, lodash2.defer = defer2, lodash2.delay = delay, lodash2.difference = difference, lodash2.differenceBy = differenceBy, lodash2.differenceWith = differenceWith, lodash2.drop = drop, lodash2.dropRight = dropRight, lodash2.dropRightWhile = dropRightWhile, lodash2.dropWhile = dropWhile, lodash2.fill = fill, lodash2.filter = filter2, lodash2.flatMap = flatMap, lodash2.flatMapDeep = flatMapDeep, lodash2.flatMapDepth = flatMapDepth, lodash2.flatten = flatten, lodash2.flattenDeep = flattenDeep, lodash2.flattenDepth = flattenDepth, lodash2.flip = flip, lodash2.flow = flow, lodash2.flowRight = flowRight, lodash2.fromPairs = fromPairs, lodash2.functions = functions, lodash2.functionsIn = functionsIn, lodash2.groupBy = groupBy, lodash2.initial = initial, lodash2.intersection = intersection, lodash2.intersectionBy = intersectionBy, lodash2.intersectionWith = intersectionWith, lodash2.invert = invert, lodash2.invertBy = invertBy, lodash2.invokeMap = invokeMap, lodash2.iteratee = iteratee, lodash2.keyBy = keyBy, lodash2.keys = keys, lodash2.keysIn = keysIn, lodash2.map = map2, lodash2.mapKeys = mapKeys, lodash2.mapValues = mapValues, lodash2.matches = matches, lodash2.matchesProperty = matchesProperty, lodash2.memoize = memoize, lodash2.merge = merge2, lodash2.mergeWith = mergeWith, lodash2.method = method, lodash2.methodOf = methodOf, lodash2.mixin = mixin, lodash2.negate = negate, lodash2.nthArg = nthArg, lodash2.omit = omit, lodash2.omitBy = omitBy, lodash2.once = once, lodash2.orderBy = orderBy, lodash2.over = over, lodash2.overArgs = overArgs, lodash2.overEvery = overEvery, lodash2.overSome = overSome, lodash2.partial = partial, lodash2.partialRight = partialRight, lodash2.partition = partition, lodash2.pick = pick, lodash2.pickBy = pickBy, lodash2.property = property, lodash2.propertyOf = propertyOf, lodash2.pull = pull, lodash2.pullAll = pullAll, lodash2.pullAllBy = pullAllBy, lodash2.pullAllWith = pullAllWith, lodash2.pullAt = pullAt, lodash2.range = range, lodash2.rangeRight = rangeRight, lodash2.rearg = rearg, lodash2.reject = reject, lodash2.remove = remove, lodash2.rest = rest, lodash2.reverse = reverse, lodash2.sampleSize = sampleSize, lodash2.set = set, lodash2.setWith = setWith, lodash2.shuffle = shuffle, lodash2.slice = slice, lodash2.sortBy = sortBy, lodash2.sortedUniq = sortedUniq, lodash2.sortedUniqBy = sortedUniqBy, lodash2.split = split, lodash2.spread = spread, lodash2.tail = tail, lodash2.take = take, lodash2.takeRight = takeRight, lodash2.takeRightWhile = takeRightWhile, lodash2.takeWhile = takeWhile, lodash2.tap = tap2, lodash2.throttle = throttle, lodash2.thru = thru, lodash2.toArray = toArray2, lodash2.toPairs = toPairs, lodash2.toPairsIn = toPairsIn, lodash2.toPath = toPath, lodash2.toPlainObject = toPlainObject, lodash2.transform = transform, lodash2.unary = unary, lodash2.union = union, lodash2.unionBy = unionBy, lodash2.unionWith = unionWith, lodash2.uniq = uniq, lodash2.uniqBy = uniqBy, lodash2.uniqWith = uniqWith, lodash2.unset = unset, lodash2.unzip = unzip, lodash2.unzipWith = unzipWith, lodash2.update = update, lodash2.updateWith = updateWith, lodash2.values = values, lodash2.valuesIn = valuesIn, lodash2.without = without, lodash2.words = words, lodash2.wrap = wrap, lodash2.xor = xor, lodash2.xorBy = xorBy, lodash2.xorWith = xorWith, lodash2.zip = zip, lodash2.zipObject = zipObject, lodash2.zipObjectDeep = zipObjectDeep, lodash2.zipWith = zipWith, lodash2.entries = toPairs, lodash2.entriesIn = toPairsIn, lodash2.extend = assignIn, lodash2.extendWith = assignInWith, mixin(lodash2, lodash2), lodash2.add = add, lodash2.attempt = attempt, lodash2.camelCase = camelCase, lodash2.capitalize = capitalize, lodash2.ceil = ceil, lodash2.clamp = clamp, lodash2.clone = clone, lodash2.cloneDeep = cloneDeep, lodash2.cloneDeepWith = cloneDeepWith, lodash2.cloneWith = cloneWith, lodash2.conformsTo = conformsTo, lodash2.deburr = deburr, lodash2.defaultTo = defaultTo, lodash2.divide = divide, lodash2.endsWith = endsWith, lodash2.eq = eq, lodash2.escape = escape, lodash2.escapeRegExp = escapeRegExp, lodash2.every = every, lodash2.find = find, lodash2.findIndex = findIndex, lodash2.findKey = findKey, lodash2.findLast = findLast, lodash2.findLastIndex = findLastIndex, lodash2.findLastKey = findLastKey, lodash2.floor = floor, lodash2.forEach = forEach, lodash2.forEachRight = forEachRight, lodash2.forIn = forIn, lodash2.forInRight = forInRight, lodash2.forOwn = forOwn, lodash2.forOwnRight = forOwnRight, lodash2.get = get, lodash2.gt = gt, lodash2.gte = gte, lodash2.has = has, lodash2.hasIn = hasIn, lodash2.head = head, lodash2.identity = identity, lodash2.includes = includes, lodash2.indexOf = indexOf, lodash2.inRange = inRange, lodash2.invoke = invoke, lodash2.isArguments = isArguments, lodash2.isArray = isArray, lodash2.isArrayBuffer = isArrayBuffer, lodash2.isArrayLike = isArrayLike, lodash2.isArrayLikeObject = isArrayLikeObject, lodash2.isBoolean = isBoolean, lodash2.isBuffer = isBuffer, lodash2.isDate = isDate, lodash2.isElement = isElement, lodash2.isEmpty = isEmpty, lodash2.isEqual = isEqual, lodash2.isEqualWith = isEqualWith, lodash2.isError = isError, lodash2.isFinite = isFinite, lodash2.isFunction = isFunction, lodash2.isInteger = isInteger, lodash2.isLength = isLength, lodash2.isMap = isMap, lodash2.isMatch = isMatch, lodash2.isMatchWith = isMatchWith, lodash2.isNaN = isNaN, lodash2.isNative = isNative, lodash2.isNil = isNil, lodash2.isNull = isNull, lodash2.isNumber = isNumber, lodash2.isObject = isObject, lodash2.isObjectLike = isObjectLike, lodash2.isPlainObject = isPlainObject, lodash2.isRegExp = isRegExp, lodash2.isSafeInteger = isSafeInteger, lodash2.isSet = isSet, lodash2.isString = isString, lodash2.isSymbol = isSymbol, lodash2.isTypedArray = isTypedArray, lodash2.isUndefined = isUndefined, lodash2.isWeakMap = isWeakMap, lodash2.isWeakSet = isWeakSet, lodash2.join = join, lodash2.kebabCase = kebabCase, lodash2.last = last, lodash2.lastIndexOf = lastIndexOf, lodash2.lowerCase = lowerCase, lodash2.lowerFirst = lowerFirst, lodash2.lt = lt, lodash2.lte = lte, lodash2.max = max, lodash2.maxBy = maxBy, lodash2.mean = mean, lodash2.meanBy = meanBy, lodash2.min = min, lodash2.minBy = minBy, lodash2.stubArray = stubArray, lodash2.stubFalse = stubFalse, lodash2.stubObject = stubObject, lodash2.stubString = stubString, lodash2.stubTrue = stubTrue, lodash2.multiply = multiply, lodash2.nth = nth, lodash2.noConflict = noConflict, lodash2.noop = noop, lodash2.now = now, lodash2.pad = pad, lodash2.padEnd = padEnd, lodash2.padStart = padStart, lodash2.parseInt = parseInt2, lodash2.random = random, lodash2.reduce = reduce, lodash2.reduceRight = reduceRight, lodash2.repeat = repeat, lodash2.replace = replace, lodash2.result = result, lodash2.round = round, lodash2.runInContext = runInContext2, lodash2.sample = sample, lodash2.size = size, lodash2.snakeCase = snakeCase, lodash2.some = some, lodash2.sortedIndex = sortedIndex, lodash2.sortedIndexBy = sortedIndexBy, lodash2.sortedIndexOf = sortedIndexOf, lodash2.sortedLastIndex = sortedLastIndex, lodash2.sortedLastIndexBy = sortedLastIndexBy, lodash2.sortedLastIndexOf = sortedLastIndexOf, lodash2.startCase = startCase, lodash2.startsWith = startsWith2, lodash2.subtract = subtract, lodash2.sum = sum, lodash2.sumBy = sumBy, lodash2.template = template, lodash2.times = times, lodash2.toFinite = toFinite, lodash2.toInteger = toInteger, lodash2.toLength = toLength, lodash2.toLower = toLower, lodash2.toNumber = toNumber, lodash2.toSafeInteger = toSafeInteger, lodash2.toString = toString, lodash2.toUpper = toUpper, lodash2.trim = trim, lodash2.trimEnd = trimEnd, lodash2.trimStart = trimStart, lodash2.truncate = truncate, lodash2.unescape = unescape, lodash2.uniqueId = uniqueId, lodash2.upperCase = upperCase, lodash2.upperFirst = upperFirst, lodash2.each = forEach, lodash2.eachRight = forEachRight, lodash2.first = head, mixin(lodash2, function() {
        var source = {};
        return baseForOwn(lodash2, function(func, methodName) {
          hasOwnProperty.call(lodash2.prototype, methodName) || (source[methodName] = func);
        }), source;
      }(), { chain: !1 }), lodash2.VERSION = VERSION, arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      }), arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          return result2.__filtered__ ? result2.__takeCount__ = nativeMin(n, result2.__takeCount__) : result2.__views__.push({
            size: nativeMin(n, MAX_ARRAY_LENGTH),
            type: methodName + (result2.__dir__ < 0 ? "Right" : "")
          }), result2;
        }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      }), arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          return result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          }), result2.__filtered__ = result2.__filtered__ || isFilter, result2;
        };
      }), arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      }), arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      }), LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      }, LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      }, LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      }, LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        return typeof path == "function" ? new LazyWrapper(this) : this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      }), LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      }, LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        return result2.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result2) : (start < 0 ? result2 = result2.takeRight(-start) : start && (result2 = result2.drop(start)), end !== undefined$1 && (end = toInteger(end), result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start)), result2);
      }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      }, LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        lodashFunc && (lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value), interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1 && (isLazy = useLazy = !1);
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            return result2.__actions__.push({ func: thru, args: [interceptor], thisArg: undefined$1 }), new LodashWrapper(result2, chainAll);
          }
          return isUnwrapped && onlyLazy ? func.apply(this, args) : (result2 = this.thru(interceptor), isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2);
        });
      }), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          hasOwnProperty.call(realNames, key) || (realNames[key] = []), realNames[key].push({ name: methodName, func: lodashFunc });
        }
      }), realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined$1
      }], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, LazyWrapper.prototype.value = lazyValue, lodash2.prototype.at = wrapperAt, lodash2.prototype.chain = wrapperChain, lodash2.prototype.commit = wrapperCommit, lodash2.prototype.next = wrapperNext, lodash2.prototype.plant = wrapperPlant, lodash2.prototype.reverse = wrapperReverse, lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue, lodash2.prototype.first = lodash2.prototype.head, symIterator && (lodash2.prototype[symIterator] = wrapperToIterator), lodash2;
    }, _ = runInContext();
    freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root._ = _;
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
function mergeMutationGroups(mutationGroups) {
  return chunkWhile(mutationGroups, (group) => !group.transaction).flatMap(
    (chunk) => ({
      ...chunk[0],
      mutations: chunk.flatMap((c) => c.mutations)
    })
  );
}
function chunkWhile(arr, predicate) {
  const res = [];
  let currentChunk = [];
  return arr.forEach((item) => {
    predicate(item) ? currentChunk.push(item) : (currentChunk.length > 0 && res.push(currentChunk), currentChunk = [], res.push([item]));
  }), currentChunk.length > 0 && res.push(currentChunk), res;
}
function squashMutationGroups(staged) {
  return mergeMutationGroups(staged).map((transaction) => ({
    ...transaction,
    mutations: squashMutations(transaction.mutations)
  })).map((transaction) => ({
    ...transaction,
    mutations: transaction.mutations.map((mutation) => mutation.type !== "patch" ? mutation : {
      ...mutation,
      patches: squashNodePatches(mutation.patches)
    })
  }));
}
function squashMutations(mutations) {
  const byDocument = lodashExports.groupBy(mutations, getMutationDocumentId);
  return Object.values(byDocument).flatMap((documentMutations) => squashCreateIfNotExists(squashDelete(documentMutations)).flat().reduce((acc, docMutation) => {
    const prev = acc[acc.length - 1];
    return (!prev || prev.type === "patch") && docMutation.type === "patch" ? acc.slice(0, -1).concat({
      ...docMutation,
      patches: ((prev == null ? void 0 : prev.patches) || []).concat(docMutation.patches)
    }) : acc.concat(docMutation);
  }, []));
}
function squashCreateIfNotExists(mutations) {
  return mutations.length === 0 ? mutations : mutations.reduce((previousMuts, laterMut) => laterMut.type !== "createIfNotExists" ? (previousMuts.push(laterMut), previousMuts) : (takeUntilRight(previousMuts, (m) => m.type === "delete").find(
    (precedingPatch) => precedingPatch.type === "createIfNotExists"
  ) || previousMuts.push(laterMut), previousMuts), []);
}
function squashDelete(mutations) {
  return mutations.length === 0 ? mutations : mutations.reduce((previousMuts, laterMut) => laterMut.type === "delete" ? [laterMut] : (previousMuts.push(laterMut), previousMuts), []);
}
function rebase(documentId, oldBase, newBase, stagedMutations) {
  let edge = oldBase;
  const dmpified = stagedMutations.map((transaction) => {
    const mutations = transaction.mutations.flatMap((mut) => {
      if (getMutationDocumentId(mut) !== documentId)
        return [];
      const before = edge;
      return edge = applyAll(edge, [mut]), !before || mut.type !== "patch" ? mut : {
        type: "dmpified",
        mutation: {
          ...mut,
          // Todo: make compactDMPSetPatches return pairs of patches that was dmpified with their
          //  original as dmpPatches and original is not 1:1 (e..g some of the original may not be dmpified)
          dmpPatches: compactDMPSetPatches(before, mut.patches),
          original: mut.patches
        }
      };
    });
    return { ...transaction, mutations };
  });
  let newBaseWithDMPForOldBaseApplied = newBase;
  return dmpified.map((transaction) => {
    const applied = [];
    return transaction.mutations.forEach((mut) => {
      if (mut.type === "dmpified")
        try {
          newBaseWithDMPForOldBaseApplied = applyPatches(
            mut.mutation.dmpPatches,
            newBaseWithDMPForOldBaseApplied
          ), applied.push(mut);
        } catch {
          console.warn("Failed to apply dmp patch, falling back to original");
          try {
            newBaseWithDMPForOldBaseApplied = applyPatches(
              mut.mutation.original,
              newBaseWithDMPForOldBaseApplied
            ), applied.push(mut);
          } catch (second) {
            throw new Error(
              `Failed to apply patch for document "${documentId}": ${second.message}`
            );
          }
        }
      else
        newBaseWithDMPForOldBaseApplied = applyAll(
          newBaseWithDMPForOldBaseApplied,
          [mut]
        );
    });
  }), [stagedMutations.map((transaction) => ({
    ...transaction,
    mutations: transaction.mutations.map((mut) => mut.type !== "patch" || getMutationDocumentId(mut) !== documentId ? mut : {
      ...mut,
      patches: mut.patches.map((patch2) => patch2.op.type !== "set" ? patch2 : {
        ...patch2,
        op: {
          ...patch2.op,
          value: getAtPath(patch2.path, newBaseWithDMPForOldBaseApplied)
        }
      })
    })
  })), newBaseWithDMPForOldBaseApplied];
}
function createReplayMemoizer(expiry) {
  const memo = /* @__PURE__ */ Object.create(null);
  return function(key, observable) {
    return key in memo || (memo[key] = observable.pipe(
      finalize(() => {
        delete memo[key];
      }),
      share({
        connector: () => new ReplaySubject(1),
        resetOnRefCountZero: () => timer(expiry)
      })
    )), memo[key];
  };
}
function filterMutationGroupsById(mutationGroups, id) {
  return mutationGroups.flatMap(
    (mutationGroup) => mutationGroup.mutations.flatMap(
      (mut) => getMutationDocumentId(mut) === id ? [mut] : []
    )
  );
}
let didEmitMutationsAccessWarning = !1;
function warnNoMutationsReceived() {
  didEmitMutationsAccessWarning || (console.warn(
    new Error(
      "No mutation received from backend. The listener is likely set up with `excludeMutations: true`. If your app need to now about mutations, make sure the listener is set up to include mutations"
    )
  ), didEmitMutationsAccessWarning = !0);
}
const EMPTY_ARRAY = [];
function createContentLakeStore(backend) {
  const local = createDataset(), remote = createDataset(), memoize = createReplayMemoizer(1e3);
  let stagedChanges = [];
  const remoteEvents$ = new Subject(), localMutations$ = new Subject(), stage$ = new Subject();
  function stage(nextPending) {
    stagedChanges = nextPending, stage$.next();
  }
  function getLocalEvents(id) {
    return localMutations$.pipe(filter((event) => event.id === id));
  }
  function getRemoteEvents(id) {
    return backend.observe(id).pipe(
      filter(
        (event) => event.type !== "reconnect"
      ),
      mergeMap((event) => {
        const oldLocal = local.get(id), oldRemote = remote.get(id);
        if (event.type === "sync") {
          const newRemote = event.document, [rebasedStage, newLocal] = rebase(
            id,
            oldRemote,
            newRemote,
            stagedChanges
          );
          return of({
            type: "sync",
            id,
            before: { remote: oldRemote, local: oldLocal },
            after: { remote: newRemote, local: newLocal },
            rebasedStage
          });
        } else if (event.type === "mutation") {
          if (event.transactionId === (oldRemote == null ? void 0 : oldRemote._rev))
            return EMPTY;
          const newRemote = applyMendozaPatch(oldRemote, event.effects);
          newRemote && (newRemote._rev = event.transactionId);
          const [rebasedStage, newLocal] = rebase(
            id,
            oldRemote,
            newRemote,
            stagedChanges
          );
          newLocal && (newLocal._rev = event.transactionId);
          const emittedEvent = {
            type: "mutation",
            id,
            rebasedStage,
            before: { remote: oldRemote, local: oldLocal },
            after: { remote: newRemote, local: newLocal },
            effects: event.effects,
            // overwritten below
            mutations: EMPTY_ARRAY
          };
          return event.mutations ? emittedEvent.mutations = decodeAll(
            event.mutations
          ) : Object.defineProperty(
            emittedEvent,
            "mutations",
            warnNoMutationsReceived
          ), of(emittedEvent);
        } else
          throw new Error(`Unknown event type: ${event.type}`);
      }),
      tap((event) => {
        local.set(event.id, event.after.local), remote.set(event.id, event.after.remote), stage(event.rebasedStage);
      }),
      tap({
        next: (event) => remoteEvents$.next(event),
        error: (err) => {
        }
      })
    );
  }
  function observeEvents(id) {
    return defer(
      () => memoize(id, merge(getLocalEvents(id), getRemoteEvents(id)))
    );
  }
  return {
    meta: {
      events: merge(localMutations$, remoteEvents$),
      stage: stage$.pipe(
        map(
          () => (
            // note: this should not be tampered with by consumers. We might want to do a deep-freeze during dev to avoid accidental mutations
            stagedChanges
          )
        )
      ),
      conflicts: EMPTY
      // does nothing for now
    },
    mutate: (mutations) => {
      stagedChanges.push({ transaction: !1, mutations });
      const results = applyMutations(mutations, local);
      return commit(results, local), results.forEach((result) => {
        localMutations$.next({
          type: "optimistic",
          before: result.before,
          after: result.after,
          mutations: result.mutations,
          id: result.id,
          stagedChanges: filterMutationGroupsById(stagedChanges, result.id)
        });
      }), results;
    },
    transaction: (mutationsOrTransaction) => {
      const transaction = Array.isArray(
        mutationsOrTransaction
      ) ? { mutations: mutationsOrTransaction, transaction: !0 } : { ...mutationsOrTransaction, transaction: !0 };
      stagedChanges.push(transaction);
      const results = applyMutations(transaction.mutations, local);
      return commit(results, local), results.forEach((result) => {
        localMutations$.next({
          type: "optimistic",
          mutations: result.mutations,
          id: result.id,
          before: result.before,
          after: result.after,
          stagedChanges: filterMutationGroupsById(stagedChanges, result.id)
        });
      }), results;
    },
    observeEvents,
    observe: (id) => observeEvents(id).pipe(
      map(
        (event) => event.type === "optimistic" ? event.after : event.after.local
      )
    ),
    optimize: () => {
      stage(squashMutationGroups(stagedChanges));
    },
    submit: () => {
      const pending = stagedChanges;
      return stage([]), lastValueFrom(
        backend.submit(
          toTransactions(
            // Squashing DMP strings is the last thing we do before submitting
            squashDMPStrings(remote, squashMutationGroups(pending))
          )
        ).pipe(toArray())
      );
    }
  };
}
function toTransactions(groups) {
  return groups.map((group) => group.transaction && group.id !== void 0 ? { id: group.id, mutations: group.mutations } : { mutations: group.mutations });
}
export {
  createContentLakeStore
};
//# sourceMappingURL=_unstable_store.esm.js.map
